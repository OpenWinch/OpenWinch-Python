@startuml

skinparam class {
    BackgroundColor White
    ArrowColor Grey
    BorderColor Black
}

skinparam titleBorderRoundCorner 5
skinparam titleBorderThickness 2
skinparam titleBorderColor black

title Class Diagram - **OpenWinch**

header
Version 0.1.0 by Mickael Gaillard
endheader

center footer
Generated at %date("dd/MM/yyyy HH:mm")
OpenWinch Â© 2020-%date("yyyy")
endfooter

namespace openwinch.state {

    enum State {
        UNKNOWN = -999
        BOOTED = -2
        ERROR = -1
        INIT = 0
        IDLE = 1
        START = 2
        RUNNING = 3
        STOP = 4
        {static}+checkRun(current): bool
        {static}+checkStop(current): bool
        {static}+checkFault(current): bool
        {static}+checkInit(current): bool
        {static}+checkBoot(current): bool
        +isRun() : bool
        +isStop() : bool
        +isFault() : bool
        +isInit() : bool
        +isBoot() : bool
    }
}

namespace openwinch.controller {

    class Winch {
        -controlLoop: Thread = None
        -speed_target = SPEED_INIT
        -banner(): void
        -changeState(state: State): void
        -initControlLoop(): void
        -loadConfig(): void
        +display(): void
        +emergency(): void
        +enterGui(value: InputType): void
        +getBattery(): int
        +getDistance(): float
        +getMode(): ModeType
        +getRemote(): int
        +getSpeedTarget(): int
        +getState(): State
        +initialize(): void
        +initialized(): void
        +speedDown(value=1): void
        +speedUp(value=1): void
        +speedValue(value): void
        +start(): void
        +started(): void
        +stop(): void
        +stopped(): void
    }

    Winch o-left-> "state" openwinch.state.State
}

namespace openwinch.mode {

    enum ModeType {
        OneWay = 1
        TwoWay = 2
        Infinity = 3
        +list(): Map
    }

    abstract class ModeFactory {
        {static}+modeFactory(winch: Winch, board: Board, mode: ModeType) : ModeEngine
        {static}+getMode(modeEngine: ModeEngine) : ModeType
    }

    abstract class ModeEngine {
        -security_begin: int = 20
        -speed_ratio: float = 1
        -velocity_start: int = 1
        -velocity_stop: int = 3
        #speed_current = 0
        -initialize(): void
        -starting(): void
        -stopping(): void
        -fault(): void
        {abstract}#extraMode(): void
        #isBeginSecurity(): bool
        +applyThrottleValue(): void
        +getDistance(): float
        +getSpeedCurrent() : int
        +runControlLoop(): void
    }

    class OneWayMode extends ModeEngine {
        #extraMode(): void
    }
    class TwoWayMode extends ModeEngine{
        #extraMode(): void
        #isEndSecurity(): bool
    }
    class InfinityMode extends ModeEngine{
        #extraMode(): void
    }

    ModeEngine o-right-> "board" openwinch.hardware.Board
    ModeEngine "mode" o-up- "winch" openwinch.controller.Winch
    ModeEngine .left.> ModeType
    ModeFactory .up.> OneWayMode
    ModeFactory .up.> TwoWayMode
    ModeFactory .up.> InfinityMode
}

namespace openwinch.hardware {

    enum SpeedMode {
        LOW = 0
        MEDIUM = 1
        HIGH = 2
    }

    abstract class Board {
        -reverse: boolean = False
        -speed_mode: SpeedMode = SpeedMode.LOW
        -rotation_from_init: int = 0
        {abstract}+emergency(): void
        +getBattery(): int
        +getRotationFromBegin(): int
        +getRotationFromEnd(): int
        +getSpeedMode(): SpeedMode
        {abstract}+getThrottleValue(): float
        {abstract}+initialize(): void
        +isReverse(): bool
        {abstract}+setReverse(enable: boolean): void
        {abstract}+setSpeedMode(speed_mode: SpeedMode): void
        {abstract}+setThrottleValue(value: float): void
    }

    class Emulator extends Board {
        -value: int = 0
        -init: boolean = False
        +emergency(): void
        +getThrottleValue(): float
        +initialize(): void
        +setReverse(enable: boolean): void
        +setSpeedMode(speed_mode: SpeedMode): void
        +setThrottleValue(value: float): void
    }

    class RaspberryPi extends Board {
        -power_cmd: OutputDevice
        -reverse_cmd: OutputDevice
        -speed_cmd: OutputDevice
        -throttle_cmd: PWMOutputDevice
        -key_enter_btn: Button
        -key_left_btn: Button
        -key_right_btn: Button
        +emergency(): void
        +getThrottleValue() : float
        +initialize(): void
        +setReverse(enable: boolean): void
        +setSpeedMode(speed_mode: SpeedMode): void
        +setThrottleValue(value: float): void
    }

    Board ..> SpeedMode
    Board "board" o-up- "winch" openwinch.controller.Winch
    Board ..> openwinch.input.InputType
}

namespace openwinch.display {

    enum GuiType {
        DISABLE = 0
        SH1106_I2C = 1
        VGA = 100
        CAPTURE = 101
    }

    class Gui {
        -device: luma.device = None
        -display_draw_Loop: Thread = None
        +cursor_pos: int
        +view_pos; int
        -drawBoot(): void
        -drawLoop(): void
        +boot(self): boot
        +createMenuIcon(self, draw, items): void
        +createMenuScroll(self, draw, items, selected_item=None): void
        +createValue(self, draw, title, value): void
        +display(self): void
        +enter(self, key: InputType): void
        +extractScreen(self): void
        +getPos(self): int
        +getWinch(self): Winch
        +statusBar(self, draw): void
    }

    Gui "gui" o-right- "screen" ScreenBase
    Gui "gui" o-up-> "winch" openwinch.controller.Winch
    Gui ..> GuiType
    Gui ..> openwinch.input.InputType

    abstract class ScreenBase {
        {abstract}+countItems(self): int
        {abstract}+display(self, draw): void
        {abstract}+enter(self, cursor_pos): void
    }

    class MainScreen extends ScreenBase {
        -animateDistance(): void
        +countItems(self): int
        +display(self, draw): void
        +enter(self, cursor_pos): void
    }

    class MenuScreen extends ScreenBase {
        +countItems(self): int
        +display(self, draw): void
        +enter(self, cursor_pos): void
    }

    class ManualPositionScreen extends ScreenBase {
        +countItems(self): int
        +display(self, draw): void
        +enter(self, cursor_pos): void
    }

    class SecurityDistanceScreen extends ScreenBase {
        +TITLE
        +value
        +countItems(self): int
        +display(self, draw): void
        +enter(self, cursor_pos): void
    }

    class ModeSelectorScreen extends ScreenBase {
        +countItems(self): int
        +display(self, draw): void
        +enter(self, cursor_pos): void
    }

    class VelocityStartScreen extends ScreenBase {
        +TITLE
        +value
        +countItems(self): int
        +display(self, draw): void
        +enter(self, cursor_pos): void
    }

    class VelocityStopScreen extends ScreenBase {
        +TITLE
        +value
        +countItems(self): int
        +display(self, draw): void
        +enter(self, cursor_pos): void
    }
}

namespace openwinch.input {
    enum InputType {
        UP = 1
        RIGHT = 2
        DOWN = 3
        LEFT = 4
        ENTER = DOWN
    }
}

namespace openwinch.keyboard {
    class Keyboard {
        -controlLoop: Thread
        -runControlLoop(): void
        +get(): InputType
    }

    Keyboard ..> openwinch.input.InputType
    openwinch.controller.Winch "winch" -- "Input" Keyboard
}

namespace openwinch.config {
    class Config {
        +BOARD: String = "openwinch.hardwarePi.RaspberryPi"
        +MODE: String = "ModeType.OneWay"
        +GUI: String = "SH1106_I2C"
    }

    openwinch.controller.Winch .right.> Config
}

@enduml
